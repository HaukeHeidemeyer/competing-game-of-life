<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Competing Game of Life - UI Controls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
        }

        /* Canvas container to ensure it stays behind UI */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 1px solid #333;
            /* Ensure pixels stay sharp */
            image-rendering: pixelated; 
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            
            background-color: rgba(30, 30, 30, 0.85);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 50px;
            border: 1px solid #555;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);

            display: flex;
            gap: 15px;
            align-items: center;
        }

        button {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #666;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        /* Specific button colors */
        #btn-play.running { background-color: #d9534f; } /* Red when running (Stop) */
        #btn-play.paused { background-color: #5cb85c; }  /* Green when paused (Play) */

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            border-left: 1px solid #555;
            padding-left: 15px;
        }

        label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
        }

        input[type=range] {
            width: 100px;
            cursor: pointer;
        }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="golCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <button id="btn-play" class="running">Pause</button>
        <button id="btn-step">Step</button>
        
        <div class="control-group">
            <button id="btn-random">Random</button>
            <button id="btn-clear">Clear</button>
        </div>

        <div class="control-group">
            <label for="speed-slider">Speed</label>
            <input type="range" id="speed-slider" min="1" max="100" value="50">
        </div>
    </div>

    <script>
        'use strict';

        // --- Configuration ---
        const GRID_WIDTH = 1600;
        const GRID_HEIGHT = 1200;
        const GRID_SIZE = GRID_WIDTH * GRID_HEIGHT;
        
        // Simulation State
        let isRunning = true;
        let updateIntervalMs = 50; // Controlled by slider
        let lastTime = 0;

        // States
        const DEAD = 0, WHITE = 1, RED = 2, BLUE = 3;
        const NUM_COLORS = 3;
        const STATE_COLORS = [
            [0, 0, 0, 255],       // DEAD (Black)
            [255, 255, 255, 255], // WHITE
            [255, 50, 50, 255],   // RED
            [50, 50, 255, 255]    // BLUE
        ];

        // --- Memory Allocation (Static Buffers) ---
        let currentGrid = new Uint8Array(GRID_SIZE);
        let nextGrid = new Uint8Array(GRID_SIZE);
        
        // Optimization buffers
        const neighborCounts = new Int32Array(NUM_COLORS); 
        const birthQueue = new Int32Array(GRID_SIZE); 
        let birthQueueCount = 0;
        const victimCandidates = new Int32Array(8);

        // --- Canvas Setup ---
        const canvas = document.getElementById('golCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        canvas.width = GRID_WIDTH;
        canvas.height = GRID_HEIGHT;

        const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);
        const buf32 = new Uint32Array(imageData.data.buffer);

        // Endianness check
        const isLittleEndian = (() => {
            const buffer = new ArrayBuffer(4);
            new Uint8Array(buffer)[0] = 1;
            return new Uint32Array(buffer)[0] === 1;
        })();

        // Pre-calculate 32-bit colors
        const COLORS_32 = STATE_COLORS.map(c => {
            if (isLittleEndian) {
                return (c[3] << 24) | (c[2] << 16) | (c[1] << 8) | c[0];
            } else {
                return (c[0] << 24) | (c[1] << 16) | (c[2] << 8) | c[3];
            }
        });

        // --- PRNG ---
        let seed = Date.now();
        function fastRandom() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // --- Logic ---

        function computeNextGeneration() {
            birthQueueCount = 0; 

            // PASS 1: Calculate Survival and Queued Births
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const idx = y * GRID_WIDTH + x;
                    const currentState = currentGrid[idx];

                    // Reset counts
                    neighborCounts[0] = 0; neighborCounts[1] = 0; neighborCounts[2] = 0;

                    // Count Neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            // Inline wrap
                            let nx = x + dx;
                            let ny = y + dy;
                            if (nx < 0) nx = GRID_WIDTH - 1; else if (nx >= GRID_WIDTH) nx = 0;
                            if (ny < 0) ny = GRID_HEIGHT - 1; else if (ny >= GRID_HEIGHT) ny = 0;
                            
                            const nState = currentGrid[ny * GRID_WIDTH + nx];
                            if (nState !== DEAD) neighborCounts[nState - 1]++;
                        }
                    }

                    if (currentState === DEAD) {
                        let birthColor = 0;
                        let candidates = 0;
                        if (neighborCounts[0] === 3) { birthColor = 1; candidates++; }
                        if (neighborCounts[1] === 3) { birthColor = 2; candidates++; }
                        if (neighborCounts[2] === 3) { birthColor = 3; candidates++; }

                        if (candidates === 1) {
                            nextGrid[idx] = birthColor;
                            birthQueue[birthQueueCount++] = idx;
                        } else {
                            nextGrid[idx] = DEAD;
                        }
                    } else {
                        const sameColorCount = neighborCounts[currentState - 1];
                        if (sameColorCount < 2 || sameColorCount > 3) {
                            nextGrid[idx] = DEAD;
                        } else {
                            nextGrid[idx] = currentState;
                        }
                    }
                }
            }

            // PASS 2: Retaliation
            for (let i = 0; i < birthQueueCount; i++) {
                const idx = birthQueue[i];
                const bornColor = nextGrid[idx];
                const cy = Math.floor(idx / GRID_WIDTH);
                const cx = idx % GRID_WIDTH;
                
                let victimCount = 0;

                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;

                        let nx = cx + dx;
                        let ny = cy + dy;
                        if (nx < 0) nx = GRID_WIDTH - 1; else if (nx >= GRID_WIDTH) nx = 0;
                        if (ny < 0) ny = GRID_HEIGHT - 1; else if (ny >= GRID_HEIGHT) ny = 0;

                        const nIdx = ny * GRID_WIDTH + nx;
                        const nState = currentGrid[nIdx];
                        
                        // Victim must be alive and different color
                        if (nState !== DEAD && nState !== bornColor) {
                            victimCandidates[victimCount++] = nIdx;
                        }
                    }
                }

                if (victimCount > 0) {
                    const randIndex = Math.floor(fastRandom() * victimCount);
                    nextGrid[victimCandidates[randIndex]] = DEAD;
                }
            }
        }

        function render() {
            // Because we swap buffers, currentGrid holds the latest frame data
            for (let i = 0; i < GRID_SIZE; i++) {
                buf32[i] = COLORS_32[currentGrid[i]];
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function swapBuffers() {
            let temp = currentGrid;
            currentGrid = nextGrid;
            nextGrid = temp;
        }

        function initRandom() {
            for (let i = 0; i < GRID_SIZE; i++) {
                if (fastRandom() > 0.85) {
                    currentGrid[i] = Math.floor(fastRandom() * NUM_COLORS) + 1;
                } else {
                    currentGrid[i] = DEAD;
                }
            }
            nextGrid.set(currentGrid);
            render();
        }

        function clearGrid() {
            currentGrid.fill(DEAD);
            nextGrid.fill(DEAD);
            render();
        }

        // --- Interaction Handlers ---

        const btnPlay = document.getElementById('btn-play');
        const btnStep = document.getElementById('btn-step');
        const btnRandom = document.getElementById('btn-random');
        const btnClear = document.getElementById('btn-clear');
        const sliderSpeed = document.getElementById('speed-slider');

        btnPlay.addEventListener('click', () => {
            isRunning = !isRunning;
            if (isRunning) {
                btnPlay.textContent = "Pause";
                btnPlay.className = "running";
                lastTime = performance.now();
                requestAnimationFrame(loop);
            } else {
                btnPlay.textContent = "Play";
                btnPlay.className = "paused";
            }
        });

        btnStep.addEventListener('click', () => {
            // Force pause if stepping
            if (isRunning) {
                isRunning = false;
                btnPlay.textContent = "Play";
                btnPlay.className = "paused";
            }
            computeNextGeneration();
            swapBuffers();
            render();
        });

        btnRandom.addEventListener('click', () => {
            initRandom();
        });

        btnClear.addEventListener('click', () => {
            clearGrid();
            // Also stop the simulation so it doesn't just sit there processing empty frames
            if(isRunning) {
                isRunning = false;
                btnPlay.textContent = "Play";
                btnPlay.className = "paused";
            }
        });

        sliderSpeed.addEventListener('input', (e) => {
            // Map 1-100 to roughly 200ms-1ms
            // Logarithmic feel or simple inverse often feels better
            // Simple mapping:
            const val = parseInt(e.target.value);
            // Invert: 100 -> 0ms delay, 1 -> 200ms delay
            updateIntervalMs = Math.floor(200 - (val * 1.9)); 
            if (updateIntervalMs < 0) updateIntervalMs = 0;
        });

        // Mouse Painting
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = GRID_WIDTH / rect.width;
            const scaleY = GRID_HEIGHT / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;

            for (let i = 0; i < 500; i++) {
                const angle = fastRandom() * Math.PI * 2;
                const dist = fastRandom() * 30;
                const rx = Math.floor(cx + Math.cos(angle) * dist);
                const ry = Math.floor(cy + Math.sin(angle) * dist);
                const idx = (ry * GRID_WIDTH + rx + GRID_SIZE) % GRID_SIZE; // Simple safety wrap
                currentGrid[idx] = Math.floor(fastRandom() * NUM_COLORS) + 1;
            }
            // If paused, we need to render manually to see the splash
            if (!isRunning) render();
        });

        // --- Main Loop ---
        function loop(timestamp) {
            if (!isRunning) return;

            if (timestamp - lastTime >= updateIntervalMs) {
                computeNextGeneration();
                swapBuffers();
                render();
                lastTime = timestamp;
            }
            requestAnimationFrame(loop);
        }

        // Start
        initRandom();
        requestAnimationFrame(loop);

    </script>
</body>
</html>
