<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Competing Game of Life - Optimized</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #111;
        }
        canvas {
            border: 1px solid #444;
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
            /* Keeps the pixels sharp instead of blurry when scaled */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="golCanvas"></canvas>

    <script>
        'use strict';

        // --- Configuration ---
        const GRID_WIDTH = 1600;
        const GRID_HEIGHT = 1200;
        const GRID_SIZE = GRID_WIDTH * GRID_HEIGHT;
        const UPDATE_INTERVAL_MS = 50;

        // States
        const DEAD = 0, WHITE = 1, RED = 2, BLUE = 3;
        const NUM_COLORS = 3;
        const STATE_COLORS = [
            [0, 0, 0, 255],       // DEAD
            [255, 255, 255, 255], // WHITE
            [255, 50, 50, 255],   // RED
            [50, 50, 255, 255]    // BLUE
        ];

        // Simulation Buffers
        let currentGrid = new Uint8Array(GRID_SIZE);
        let nextGrid = new Uint8Array(GRID_SIZE);
        const neighborCounts = new Int32Array(NUM_COLORS); // Reusable buffer to prevent GC

        // --- Setup Canvas ---
        const canvas = document.getElementById('golCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        canvas.width = GRID_WIDTH;
        canvas.height = GRID_HEIGHT;

        const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);
        const buf32 = new Uint32Array(imageData.data.buffer); // Faster 32-bit pixel access

        // Pre-calculate 32-bit colors for the buffer
        const COLORS_32 = STATE_COLORS.map(c => 
            (c[3] << 24) | (c[2] << 16) | (c[1] << 8) | c[0]
        );

        // --- PRNG ---
        let seed = Date.now();
        function fastRandom() {
            seed = (seed * 1664525 + 1013904223) % 4294967296;
            return seed / 4294967296;
        }

        // --- Logic ---

        function getWrappedIdx(x, y) {
            let wx = x;
            let wy = y;
            if (wx < 0) wx = GRID_WIDTH - 1; else if (wx >= GRID_WIDTH) wx = 0;
            if (wy < 0) wy = GRID_HEIGHT - 1; else if (wy >= GRID_HEIGHT) wy = 0;
            return wy * GRID_WIDTH + wx;
        }

        function computeNextGeneration() {
            // Copy current to next as a baseline
            nextGrid.set(currentGrid);

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const idx = y * GRID_WIDTH + x;
                    const currentState = currentGrid[idx];

                    // Count neighbors efficiently
                    neighborCounts.fill(0);
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nIdx = getWrappedIdx(x + dx, y + dy);
                            const nState = currentGrid[nIdx];
                            if (nState !== DEAD) neighborCounts[nState - 1]++;
                        }
                    }

                    if (currentState === DEAD) {
                        // Birth Logic
                        let birthColor = 0;
                        let candidates = 0;
                        for (let i = 0; i < NUM_COLORS; i++) {
                            if (neighborCounts[i] === 3) {
                                birthColor = i + 1;
                                candidates++;
                            }
                        }

                        if (candidates === 1) {
                            nextGrid[idx] = birthColor;
                            // Retaliation: Kill one random neighbor of a different color
                            applyRetaliation(x, y, birthColor);
                        }
                    } else {
                        // Survival Logic
                        const sameColorCount = neighborCounts[currentState - 1];
                        if (sameColorCount < 2 || sameColorCount > 3) {
                            nextGrid[idx] = DEAD;
                        }
                    }
                }
            }
        }

        function applyRetaliation(x, y, bornColor) {
            const targets = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nIdx = getWrappedIdx(x + dx, y + dy);
                    const nState = currentGrid[nIdx];
                    if (nState !== DEAD && nState !== bornColor) {
                        targets.push(nIdx);
                    }
                }
            }
            if (targets.length > 0) {
                const victimIdx = targets[Math.floor(fastRandom() * targets.length)];
                nextGrid[victimIdx] = DEAD;
            }
        }

        function render() {
            for (let i = 0; i < GRID_SIZE; i++) {
                buf32[i] = COLORS_32[currentGrid[i]];
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Interaction ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = GRID_WIDTH / rect.width;
            const scaleY = GRID_HEIGHT / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;

            for (let i = 0; i < 500; i++) {
                const angle = fastRandom() * Math.PI * 2;
                const dist = fastRandom() * 30;
                const rx = Math.floor(cx + Math.cos(angle) * dist);
                const ry = Math.floor(cy + Math.sin(angle) * dist);
                const idx = getWrappedIdx(rx, ry);
                currentGrid[idx] = Math.floor(fastRandom() * NUM_COLORS) + 1;
            }
            render();
        });

        // --- Loop ---
        let lastTime = 0;
        function loop(timestamp) {
            if (timestamp - lastTime >= UPDATE_INTERVAL_MS) {
                computeNextGeneration();
                // Swap buffers
                let temp = currentGrid;
                currentGrid = nextGrid;
                nextGrid = temp;
                
                render();
                lastTime = timestamp;
            }
            requestAnimationFrame(loop);
        }

        // Initialize
        for (let i = 0; i < GRID_SIZE; i++) {
            if (fastRandom() > 0.85) {
                currentGrid[i] = Math.floor(fastRandom() * NUM_COLORS) + 1;
            }
        }

        requestAnimationFrame(loop);

    </script>
</body>
</html>
